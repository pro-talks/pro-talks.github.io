## Вопросы

1. Зачем добавили `Stream API`? Какой профит можно получить?

   - Функцианальный стиль, простая параллельная обработка, ленивые вычисления, "short circuit operators".

2. Как спроектировано `Stream API`?

   - Спроектировано как `pipeline`, выполнение операций отложено до последнего (lazy).

3. Как `Stream API` работает с многопоточностью?

   - По дефолту  - выключено, можно включить с помощью `.parallelStream()` или `.stream().parallel()`. Под капотом используется `ForkJoinPool`.

4. Что такое промежуточные и терминальные операции?

   - Промежуточные - все операции, которые возвращают `Stream`, остальные - терминальные, которые получают какой-то результат.

5. Как работают методы:

   - `flatMap` - объединяет вложенные `Stream`;
   - `peek ` - выполняет действие, используя `Consumer`;
   - `distinct` - удаляет дубликаты;
   - `skip` - обрезает `Stream` с начала;
   - `unordered` - говорит "забудь о порядке", чтобы выиграть в производительности.

6. Оцените алгоритмическую сложность метода `s.distinct`?

   - Смотря из какого источника образован `Stream`, если из `HashSet`, то операция ничего не будет стоить.

7. Как работает метод `.reduce()`? Что будет если операция не ассоциативная?

   - Используется для вычисления по формуле. Если операция не ассоциативная, то результаты могут плавать, так как `Stream` может быть не упорядоченным. 

     >  Не ассоциативные операции зависят от порядка элементов!

8. Что делает данный код?

   ```java
   Stream<People> stream = people.stream();
   stream.forEach(p -> System.out.println(p.getName()));
   List<String> collect = stream.map(People::getName).collect(toList());
   ```

   Получим ошибку, так как `stream` нельзя переиспользовать!

9. Как переобразовать список строк в одну с разделителем?

   - `.collect(Collectors.joining(", "));`

10. Как преобразовать 3 отдельных строки в одну с разделителем?

    ````java
    StringJoiner s2 = new StringJoiner(", ", "[", "]");
    s2.add("Red").add("Green").add("Blue");
    
    assertEquals(s2.toString(), "[Red, Green, Blue]");
    ````

11. Зачем `Stream.forEach`, когда есть `Iterable.forEach` ?

    - `Stream.forEach` - "не заботиться о порядке"!

12. Зачем сделали `Stream.forEachOrdered`?

    - Чтобы был перебор "с уважением порядка".

13. Что легче параллелизовать `ArrayList` или `LinkedList`, почему?

    - `ArrayList` так как проще и быстрее разбить на chunk'и.

14. Как происходит параллезация, если `Stream` создается от `Iterator`?

    - `Iterator` вытаскивает подряд несколько элементов отдает потоку в обработку, дальше еще несколько, дает уже другому.

15. Потокобезопасен ли `Stream.forEach` ?

    - Нет, в `forEach` передается `Consumer`, программист должен сам решать вопросы синхронизации в переданном `Consumer`.

16. Когда стоит использовать параллельную обработку на `Stream`?

    - Когда работы достаточно много, рекомендуется от 5^10 наносекунд;
    - То есть когда есть операции "жрущие" процессорное время;

17. Что такое `Spliterator<T>` и как он работает?

    - Содержит метод `Spliterator<T> trySplit()`, который вернет `null`, если не может разделить задачу и распараллелить или вернет `Spliterator<T>`, то есть разделит задачу на два куска и распараллелит ее.

18. Какие характеристики `Stream'a` (`Spliterator'a`) существуют?

    - ORDERED - упорядоченная обработка;
    - DISTINCT - различные элементы; 
    - SORTED - отсортированные;
    - SIZED - знаем количество элементов;
    - SUBSIZED - будет знать количество после того как поделимся;
    - NONNULL - в исходном `Stream` нет null'ов;
    - IMMUTALE - не мутирует исходный источник;
    - CONCURRENT - исходный источник `concurrent`.

19. Как работает метод `sum` для сложения плавающих чисел (не ассоциативной операции) ?

    - Метод `.sum()` в  стримах для `Double ` не полагается на операцию сложения плавающих чисел, которая не ассоциативна, внутри метода `sum()` реализовано сложение с коррекцией ошибок по Кэхону.
